<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <!-- -*- Mode: html -*- -->
  <head>
    <title>Plain-odbc Documentation</title>
  </head>

  <body>
    <h1>plain-odbc documentation</h1>
    <h2> Preface</h2>
    <p>
      This is the version of plain-odbc which I am using right now. 
      The API could stand some improvements, currently it is rather 
      simple. Hopefully it suffices for many uses. I thought I make 
      the current version available before I make my mind up about 
      another API. 
    </p>
    <p>
      For Information about ODBC-API, I recommend the
      <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/odbc/htm/dasdkodbcoverview.asp">
        ODBC documentation from Microsoft</a>.
    </p>
    <h2>Platforms</h2>
    <p>
      Plain-odbc uses UFFI to interface to the odbc libaries. I have tested it on 
      Windows 
      with Allegro CL Trial Edition (6.2), LispWorks Personal Edition (4.4) and 
      CLISP 2.34. An implementation of UFFI (that just works) is included. 
      It is based on the UFFI implementation of J&ouml;rg H&ouml;hle which can 
      be found in the patches setion of 
      <a href="http://sourceforge.net/projects/clisp">
        SourceForge Website of CLISP</a>.
      On Windows ODBC connections to Oracle and SQL-Server work. 
      On Linux plain-odbc has been tested with CLISP and MySQL.
    </p>
    
    <h2> Using plain-odbc </h2>
    You must load plain-odbc into lisp. plain-odbc is an asdf module, 
    so you need asdf. Make sure that asdf is able to find UFFI and plain-odbc.
    <pre>(asdf:oos 'asdf:load-op :plain-odbc)
    </pre>
    Then you have to create a connection to a database. The simplest way is 
    to use the function <code>connect</code>.
    <code>connect</code> takes 3 arguments,
    <ul>
      <li>the DSN of the datasource
      <li>the userid 
      <li>the password for the userid
    </ul>
    Example, <tt>ltrav</tt> is a DSN for an oracle database, 
    with the well known scott schema:
    <pre>
[35]> (setf *con* (plain-odbc:connect "ltrav1" "scott" "tiger"))
#&lt;ODBC-CONNECTION SERVER="LTRAV1" DBMS="Oracle" USER="scott">
</pre>
Then we create a table, for this we use the command <code>exec-command</code>.
<pre>
[41]> (plain-odbc:exec-command *con* "create table test1(x integer,y varchar2(2000))")

NIL
</pre>
Next we populate this table with data:
<pre>
[44]> (plain-odbc:exec-update *con* "insert into test1(x,y) values(1,'text1')")

1
</pre>
and the we retrieve it with
<pre>
[45]> (plain-odbc:exec-query *con* "select * from test1")

((1.0d0 "text1")) ;
("X" "Y")
</pre>
Note that the column x is retrieved as double, this is a problem with Oracle. 
    Oracle does not really have integer columns, integer is just a short hand 
    for number(37,0), and in a query this is returned as decimal. 
    And plain-odbc converts decimals to doubles.
<pre>
[46]> (plain-odbc:exec-update *con* "update test1 set y='test1.1' where x=1") 

1
</pre>
    There is no autocommit mode, every transaction has to commited explicitly. 
    <strong><em>If a connection is closed, it is rolled back.</em> </strong>
    So we have to commit the changes now:
    <pre>
[47]> (plain-odbc:commit *con*)

0
    </pre>
    And at last we close the connection
    <pre>
[48]> (plain-odbc:close-connection *con*)
    </pre>
    Any further opertaions with the connection will fail. It is not possible
    to reconnect the connection.
    For Oracle, SQL-Server and MS-Access there are special 
    functions to connect to a database without creating a DSN first. 
    Currently this works only under windows.
<pre>
[90]> (setf *con* (connect-oracle "ltrav1" "scott" "tiger"))

#&lt;ODBC-CONNECTION SERVER="ltrav1" DBMS="Oracle" USER="scott">
[91]> (exec-command *con* "create table test(id integer,text clob)")

NIL
[92]> (exec-update *con* "insert into test (id,text) values(1,'text1')")

1
[93]> (exec-query *con* "select * from test")

((1.0d0 "text1")) ;
("ID" "TEXT")
[94]> (setf stm (prepare-statement *con* "insert into test (id,text) values(?,?)" '((:integer :in) (:clob :in))))

#&lt;PLAIN-ODBC::ODBC-QUERY #x19ED9D09>
[95]> (exec-prepared-update stm (list 2 "text2"))

1

[96]> (exec-prepared-update stm (list 3 (make-string 1000000 :initial-element #\a)))

1
[97]> (commit *con*)

0

[98]> (length (caar (exec-query *con* "select text from test where id = 3")))

1000000
</pre>
 


    <h2>Classes</h2>
    <ul>
      <li><tt>odbc-connection</tt> - this is an object which represents a connection
        to a database.
        It can only be created by connecting to a database.
      <li><tt>query</tt> - this is a prepared query object. It can be created with
        <tt>prepare-statement</tt>. Prepared queries can be executed with the 
        <tt>exec-prepared...</tt> functions.
    </ul>
    <h2>Functions / Methods</h2>
    Currently most functions are implemented as methods, but you should not depend on it.
    
    <h3>Connecting</h3>
    <p>
      <br><b>[Function]</b><br>
      <tt>connect <i> dsn user password</i> </tt><br>
      <tt>connect</tt> connects to an odbc datasource, <i>dsn</i> 
      is the dsn of the datasource, <i>user</i> the user and 
      <i>password</i> the password. The return value is an 
      <tt>odbc-connection</tt>.
    </p>
    <P>
      <br><b>[Function]</b><br>
      <tt>close-connection <i>connection</i> </tt><br>
      Close the odbc connection <i>connection</i>, any pending transaction 
      is rolled back. After a connection is closed, it can not be used again.
    </p>
    <p>
      <br><b>[Function]</b><br>
      <tt>connect-generic &rest <i>args</i></tt><br>
      The function <tt>connect-generic</tt> expects that the 
      rest parameter is alternating list of keywords and strings. 
      From this list a connection string is build and used to connect 
      to a datasource. Each pair of keyword and string becomes an 
      attribute in the connection string, example:
      <tt>(connect-generic :dsn "ltrav1" :uid "scott" :pwd "tiger")</tt> 
      will create the connection string 
      <tt>"dsn=ltrav1;uid=scott;pwd=tiger"</tt> and use this connection 
      string to connect with the function 
      <tt>SQLDriverConnect</tt> of the ODBC-API.
      The user is not prompted for missing information.
      <em> Maybe this function should be called <tt>driver-connect</tt></em>? 
    </p>
    <p>
      The following functions create connections to specific kinds of databases.
      These functions need a template odbc datasource to the specific kind of
      database which is usually called 
      <tt>default-<em>databasetype</em>-dsn</tt>. This default dsn determines 
      then the used driver and some further properties. 
      For example, <tt>connect-oracle</tt> has the parameters 
      tns-name, user password. And the functions <tt>connect-access</tt> only parameter 
      is the name of the .mdb file. 
    <p>
      <br><b>[Function]</b><br>
      <tt>connect-sql-server <i>server database</i> &optional <i>user password</i></tt><br>
      Connect to sql server named <i>server</i>, the initial database is <i>database</i>. 
      If <i>user</i> and <i>password</i> are supplied the connection is made with sql server 
      authentication, if the parameters are not supplied then the connection is made with
      integrated security. The name of the template odbc datasource for this function is 
      <tt>default-sql-server-dsn</tt>.
    </p>
    <p>
      <br><b>[Function]</b><br>
      <tt>connect-oracle <i>server user password</i></tt><br>
      Connect to oracle database <i>server</i>, connecting as <i>user</i> with 
      password <i>password</i>. The name of the template odbc datasource for this function is 
      <tt>default-oracle-dsn</tt>.
    </p>
    <p>
      <br><b>[Function]</b><br>
      <tt>connect-access <i>filename</i></tt><br>
      Connect to the access database (a .mdb file) with name filename.
      The name of the template odbc datasource for this function is 
      <tt>default-access-dsn</tt>.
    </p>
    <p>
      
    <h3>Working with Connections</h3>
    <br><b>[Function]</b><br>
    <tt>exec-query <i>connection sqlstring &amp;rest parameters</i></tt><br>
    Executes a query on <i>connection</i> and returns two values:<br>
    the result set as a list of lists, i.e. a row is a list and the 
    result set is a list of rows. <br>
    The second value is a list of the column names.
    <br><b>Note:</b>
    Note: If a column is a LOB (BLOB or CLOB) then the data is retrieved
    with the ODBC function SQLGetData. This has the consequence that 
    thr following columns must also be retrieved with SQLGetData, 
    otherwise an error is raised by the driver. 
    Retrieving the following columns via 
    SQLGetData is not done automatically. Therefore if a LOB is selected
    it should be the last column.
    <br><b>Note:</b>
    The result set data is converted to lisp data automatically.
    The ODBC datatypes SQL_NUMERIC and SQL_DECIMAL are retrieved as doubles. 
    If you need the full precision and decimal rounding of the datatypes, 
    you should convert them to a string in the select statement. 
    But be carefull with  the conversion format (1.23 vs. 1,23).
  </p>
    <p>
      <br><b>[Function]</b><br>
      <tt>exec-update <i>connection sqlstring &amp;rest parameters</i></tt><br>
      Execute an update on <i>connection</i> with sql <i> sqlstring</i> 
      and returns the number of affected records. 
    </p>
    <p>
      <br><b>[Function]</b><br>
      <tt>exec-command <i>connection sqlstring &amp;rest parameters</i></tt></br>
      Execute an command on <i>connection</i> with sql <i>sqlstring</i>.
      Returns <tt>nil</tt>.
    </p>
    <p>
      <br><b>NOTE</b><br>
      The main difference between <tt>exec-update</tt> and <tt>exec-query</tt> 
      is that <tt>exec-query</tt> returns the result set of the execution and
      <tt>exec-update</tt> returns the number of affected records of this
      dml statement. <tt>exec-command</tt> returns just <tt>nil</tt>.
      For prepared statements this is different, <tt>exec-prepared-command</tt>
      returns the in/out and out parameters.
    </p>
    <P>
      <br><b>[Function]</b><br>
      <tt>commit <i>connection</i></tt><br>
      Commit a pending transaction for connection <i>connection</i>.
    </p>
    <P>
      <br><b>[Function]</b><br>
      <tt>rollback <i>connection</i></tt><br>
      Roll back a pending transaction for connection <i>connection</i>.
    </p>
    <p>
      <br><b>[Function]</b><br>
      <tt>prepare-statement <i>connection statement parameters</i></tt></br>
      Creates a prepared statement for connection <i>connection</i> and statment 
      <i>statement</i>. The parameter <i>parameters</i> is a list of the parameter
      descriptions. A parameter description is a list 
      <tt>(parametertype direction further-args ...)</tt>. 
      <tt>parametertype</tt> determines the type of parameter and is one of 
    </p>
    <!-- todo
    <h2>Columns</h2>
    -->
    <h2> Parameters </h2>
    <p>
      Plain-odbc supports the prepared statements of ODBC. In order to create 
      a prepared statement, the SQL text and the formal parameters must be 
      provided.  Later on, the prepared statement can be called by supplying
      the actual parameters only.<br/>
      It is also possible to supply parameters when calling the functions 
      <tt>exec-query</tt>, <tt>exec-update</tt> and <tt>exec-command</tt>.
      In this case the actual parameter and the parameter specification are
      combined in a list or the paramter spcification is derived from the
      actual parameter.
    </p>
    <p>
      The function  <tt>prepare-statement</tt> is called with the parameters
    <ul>
      <li> a connection,
      <li>an SQL text
      <li> a <em>&amp;rest</em>  list of ODBC parameters.
    </ul> 
    An element of this parameter list is a list, the first elment 
    is a keyword,  the second element is the direction of the parameter, one of
    <tt>:in</tt>, <tt>:out</tt> and <tt>:inout</tt>. The rest of the list are 
    additional parameters for this parameter type. 
    Currently the only parameter is the maximal length parameter parameter for 
    the string and binary (= Oracle's raw) datatypes. Instead of a list for 
    a parameter description only the name of the parameter type can be given. This is 
    equivalent to a list with two elements: the symbol and the direction <tt>:in</tt>.
    The following parameter types ares supported:
    </p>
    <table border=1>
        <tr>
          <th>Symbol</th>
          <th>Explanation</th>
          <th>ODBC Type</th>
          <th>Parameters</th>
        <tr>
          <td><tt>:string</tt></td>
          <td> a string, not very long </td>
          <td> SQL_VARCHAR</td>
          <td>length, integer optional</td>
        </tr>
        <tr>
          <td><tt>:unicode-string</tt></td>
          <td>a string, not very long</td> 
          <td>SQL_WVARCHAR</td>
          <td>length, integer optional</td>
        </tr>
        <tr>
          <td><tt>:integer</tt> </td>
          <td>an integer</td> 
          <td>SQL_INTEGER</td>
          <td></td>
        <tr>
          <td><tt>:double</tt></td>  
          <td>a double float</td>
          <td>SQL_DOUBLE</td>
          <td></td>
        </tr>
        <tr>
          <td><tt>:date</tt></td> 
          <td>a point in time, date + time of day</td>
          <td>SQL_TIMESTAMP</td>
          <td></td>
        </tr>
        <tr>
          <td><tt>:binary</tt></td> 
          <td>an array of (unsigned-byte 8), not very long</td>
          <td>SQL_VARBINARY</td>
          <td>length, integer optional</td>
        </tr>
        <tr>
          <td><tt>:clob</tt></td>  
          <td>string, a LOB datatype</td>
          <td>SQL_LONGVARCHAR</td>
          <td></td>
        </tr>
        <tr>
          <td><tt>:uclob</tt></td>  
          <td>unicode string, a LOB datatype</td>
          <td>SQL_LONGWVARCHAR</td>
          <td></td>
        </tr>
        <tr>
          <td><tt>:blob</tt></td> 
          <td>an array of (unsigned-byte 8), a LOB datatype </td>
          <td>SQL_LONGVARBINARY</td>
          <td></td>
        </tr>
    </table>
    Example:
    <pre>

[16]> (setf *stm* (prepare-statement *con* 
        "insert into emp (empno,deptno,ename,job,sal) values(?,?,?,?,?)"  
       '((:integer :in) (:integer :in) (:string :in 200) (:string :in 20) 
         (:double :in))))

#&lt;PLAIN-ODBC::ODBC-QUERY #x19ED07C5>
[17]> (exec-prepared-update *stm* (list 7999 20 "SMITH" "BOSS" 2335.96d0))

1
</pre>
    The parameter types <tt>:blob</tt> and <tt>:clob</tt> can not be used as out 
    and inout parameters. But one can select columns with datatype clob and 
    blob (the name of the type depends on the database).
    </p>
    <p>
      <br><b>[Function]</b><br>
      <tt>free-statement <i>statement</i></tt><br>
      Frees the prepared statement <i>statement</i>, after that it can not be used again.
    </p>
    <p>
      <br><b>[Function]</b><br>
      <tt>exec-prepared-query <i>query list-of-parameters</i></tt><br>
      Executes a previoulsy prepared statement <i>query</i> using the parameters in
      <i>list-of-parameters</i>. The return value is the same as for exec-query, a
      list of records in the resultset and as second value the names of the columns.
      The meta data of the result set is internally cached. If the meta data of the 
      result set changes with the invocations yo must use a new prepared statement.
      This should not happen often, but it is possible.
    </p>
    <p>
      <br><b>[Function]</b><br>
      <tt>exec-prepared-update <i>query list-of-parameters</i></tt><br>
      Executes an update with the previoulsy created prepared statement <i>query</i> 
      using the parameters in <i>list-of-parameters</i>. The return value is the number 
      of affected records.
    </p>
    <p>
      <br><b>[Function]</b><br>
      <tt>exec-prepared-command <i>query list-of-parameters</i></tt><br>
      Executes a command (stored procedure) with previously prepared statement 
      <i>query</i>. For each in or in/out parameter there must be a value in the list list-of-parameters. The return value is the list values for  the out and in/out 
      parameters.
    </p>

    <h2>Utilities</h2>
    <br><b>[Macro]</b><br>
    <tt>with-prepared-statement <i>(stm con string &amp;rest params) &amp;body body</i></tt><br>
    Execute <tt>body</tt> with <tt>stm</tt> bound to 
    <tt>(preparse-statement con string params ...)</tt>. 
    After that, the prepared statement <tt>stm</tt> is freed.
  </body>
</html>
